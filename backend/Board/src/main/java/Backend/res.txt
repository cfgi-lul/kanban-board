===== File: ./Board/dto/UserRegisterDTO.java =====
package Backend.Board.dto;

import lombok.Data;

@Data
public class UserRegisterDTO {
    private String username;
    private String password;
    private String name;
}

===== File: ./Board/dto/TaskDTO.java =====
package Backend.Board.dto;

import java.util.List;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class TaskDTO {
    private Long id;
    private String title;
    private String description;
    private List<CommentDTO> comments;
    private UserDTO createdBy;
    private UserDTO assignee;
}

===== File: ./Board/dto/TaskPreviewDTO.java =====
package Backend.Board.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class TaskPreviewDTO {
    private Long id;
    private String title;
}

===== File: ./Board/dto/ColumnDTO.java =====
package Backend.Board.dto;

import java.util.List;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ColumnDTO {
    private Long id;
    private String name;
    private List<TaskPreviewDTO> tasks;
}

===== File: ./Board/dto/BoardDTO.java =====
package Backend.Board.dto;

import java.util.List;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class BoardDTO {
    private Long id;
    private String name;
    private List<ColumnDTO> columns;
}

===== File: ./Board/dto/UserDTO.java =====
package Backend.Board.dto;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class UserDTO {
    private Long id;
    private String username;
    private String name;
}

===== File: ./Board/dto/CommentDTO.java =====
package Backend.Board.dto;

import java.time.LocalDateTime;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CommentDTO {
    private Long id;
    private String content;
    private LocalDateTime createdAt;
    private UserDTO author;
    private Long taskId;


    public CommentDTO(Long id, String content) {
        this.id = id;
        this.content = content;
    }
}

===== File: ./Board/repository/CommentRepository.java =====
package Backend.Board.repository;

import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;

import Backend.Board.model.Comment;

public interface CommentRepository extends JpaRepository<Comment, Long> {
    List<Comment> findByTaskIdOrderByCreatedAtDesc(Long taskId);
}

===== File: ./Board/repository/BoardRepository.java =====
package Backend.Board.repository;

import Backend.Board.model.Board;
import Backend.Board.model.Column;
import Backend.Board.model.Task;

import org.springframework.data.jpa.repository.EntityGraph;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.util.List;
import java.util.Optional;

public interface BoardRepository extends JpaRepository<Board, Long> {
    @EntityGraph(attributePaths = "columns")
    Optional<Board> findWithColumnsById(Long id);

    @Query("SELECT c.tasks FROM Column c WHERE c IN :columns")
    List<Task> findTasksByColumns(@Param("columns") List<Column> columns);
}

===== File: ./Board/repository/ColumnRepository.java =====
package Backend.Board.repository;

import org.springframework.data.jpa.repository.JpaRepository;

import Backend.Board.model.Column;

public interface ColumnRepository extends JpaRepository<Column, Long> {}

===== File: ./Board/repository/TaskRepository.java =====
package Backend.Board.repository;

import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import Backend.Board.model.Task;

public interface TaskRepository extends JpaRepository<Task, Long> {
    @Query("SELECT t FROM Task t JOIN FETCH t.column c JOIN FETCH c.board WHERE t.id = :id")
    Optional<Task> findByIdWithColumnAndBoard(@Param("id") Long id);
}

===== File: ./Board/repository/RoleRepository.java =====
package Backend.Board.repository;

import Backend.Board.model.Role;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

public interface RoleRepository extends JpaRepository<Role, Long> {
    Optional<Role> findByName(String name);

    boolean existsByName(String name); // Add this line
}


===== File: ./Board/repository/UserRepository.java =====
package Backend.Board.repository;

import Backend.Board.model.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);

    boolean existsByUsername(String username);
}

===== File: ./Board/repository/UserBoardRoleRepository.java =====
package Backend.Board.repository;

import Backend.Board.model.UserBoardRole;
import Backend.Board.model.BoardRoleType;
import Backend.Board.model.User;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface UserBoardRoleRepository extends JpaRepository<UserBoardRole, Long> {
    boolean existsByUserAndBoardIdAndRoleIn(User user, Long boardId, List<BoardRoleType> roles);

    Optional<UserBoardRole> findByUserAndBoardId(User user, Long boardId);
}

===== File: ./Board/config/JwtUtil.java =====
package Backend.Board.config;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;
import java.security.Key;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

@Component
public class JwtUtil {
    private final Key SECRET_KEY = Keys.secretKeyFor(SignatureAlgorithm.HS256);

    public String generateToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        return createToken(claims, userDetails.getUsername());
    }

    private String createToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
                .setClaims(claims)
                .setSubject(subject)
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 10))
                .signWith(SECRET_KEY)
                .compact();
    }

    public Boolean validateToken(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }

    public String extractUsername(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(SECRET_KEY)
                .build()
                .parseClaimsJws(token)
                .getBody()
                .getSubject();
    }

    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    private Date extractExpiration(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(SECRET_KEY)
                .build()
                .parseClaimsJws(token)
                .getBody()
                .getExpiration();
    }
}


===== File: ./Board/config/SecurityConfig.java =====
package Backend.Board.config;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.security.access.hierarchicalroles.RoleHierarchy;
import org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.access.expression.DefaultWebSecurityExpressionHandler;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfig {

    @Autowired
    private JwtRequestFilter jwtRequestFilter;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers(
                                "/api/auth/**",
                                "/v3/api-docs/**",
                                "/swagger-ui/**",
                                "/swagger-resources/**",
                                "/h2-console/**",
                                "/webjars/**")
                        .permitAll()
                        .requestMatchers("/ws/**").permitAll()
                        .anyRequest().authenticated())
                .sessionManagement(sess -> sess.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(List.of("http://localhost:4200"));
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
                converters.add(new MappingJackson2HttpMessageConverter());
            }
        };
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration)
            throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

    @Bean
    public RoleHierarchy roleHierarchy() {
        return RoleHierarchyImpl.fromHierarchy("ROLE_ADMIN > ROLE_WRITER > ROLE_READER");
    }

    @Bean
    public DefaultWebSecurityExpressionHandler webSecurityExpressionHandler() {
        DefaultWebSecurityExpressionHandler expressionHandler = new DefaultWebSecurityExpressionHandler();
        expressionHandler.setRoleHierarchy(roleHierarchy());
        return expressionHandler;
    }
}


===== File: ./Board/config/DataInitializer.java =====
package Backend.Board.config;

import Backend.Board.model.Role;
import Backend.Board.repository.RoleRepository;
import jakarta.annotation.PostConstruct;
import org.springframework.stereotype.Component;

@Component
public class DataInitializer {
    private final RoleRepository roleRepository;

    public DataInitializer(RoleRepository roleRepository) {
        this.roleRepository = roleRepository;
    }

    @PostConstruct
    public void init() {
        createRoleIfNotFound("USER");
        createRoleIfNotFound("ADMIN");
    }

    private void createRoleIfNotFound(String name) {
        if (!roleRepository.existsByName(name)) {
            Role role = new Role();
            role.setName(name);
            roleRepository.save(role);
        }
    }
}


===== File: ./Board/config/JwtRequestFilter.java =====
package Backend.Board.config;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
public class JwtRequestFilter extends OncePerRequestFilter {

    @Autowired
    private UserDetailsService userDetailsService;

    @Autowired
    private JwtUtil jwtUtil;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
            throws ServletException, IOException {
        final String authorizationHeader = request.getHeader("Authorization");

        System.out.println("Received Authorization header: " + authorizationHeader);

        if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
            String jwt = authorizationHeader.substring(7);
            String username = jwtUtil.extractUsername(jwt);

            if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);
                if (jwtUtil.validateToken(jwt, userDetails)) {
                    UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                            userDetails, null, userDetails.getAuthorities());
                    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                    SecurityContextHolder.getContext().setAuthentication(authentication);
                }
            }
        }
        chain.doFilter(request, response);
    }
}


===== File: ./Board/config/SwaggerConfig.java =====
package Backend.Board.config;

import io.swagger.v3.oas.annotations.enums.SecuritySchemeType;
import io.swagger.v3.oas.annotations.security.SecurityScheme;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.security.SecurityRequirement;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@SecurityScheme(
        name = "bearerAuth",
        type = SecuritySchemeType.HTTP,
        bearerFormat = "JWT",
        scheme = "bearer"
)
public class SwaggerConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info().title("Kanban API").version("1.0"))
                .addSecurityItem(new SecurityRequirement().addList("bearerAuth"));
    }
}


===== File: ./Board/config/WebSocketConfig.java =====
package Backend.Board.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.lang.NonNull;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

  @Override
  public void configureMessageBroker(@NonNull MessageBrokerRegistry config) {
    config.enableSimpleBroker("/topic");
    config.setApplicationDestinationPrefixes("/app");
  }

  @Override
  public void registerStompEndpoints(@NonNull StompEndpointRegistry registry) {
    registry.addEndpoint("/ws")
            .setAllowedOriginPatterns("*")
            .withSockJS();
  }
}


===== File: ./Board/controller/CommentController.java =====
package Backend.Board.controller;

import java.util.List;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

import Backend.Board.dto.CommentDTO;
import Backend.Board.exception.ResourceNotFoundException;
import Backend.Board.mappers.CommentMapper;
import Backend.Board.model.Comment;
import Backend.Board.model.Task;
import Backend.Board.model.User;
import Backend.Board.repository.CommentRepository;
import Backend.Board.repository.TaskRepository;
import Backend.Board.repository.UserRepository;

@RestController
@RequestMapping("/comments")
public class CommentController {
    private final CommentRepository commentRepository;
    private final TaskRepository taskRepository;
    private final UserRepository userRepository;

    @Autowired
    public CommentController(CommentRepository commentRepository,
                             TaskRepository taskRepository,
                             UserRepository userRepository) {
        this.commentRepository = commentRepository;
        this.taskRepository = taskRepository;
        this.userRepository = userRepository;
    }

    @GetMapping("/task/{taskId}")
    public ResponseEntity<List<CommentDTO>> getCommentsByTask(@PathVariable Long taskId) {
        List<Comment> comments = commentRepository.findByTaskIdOrderByCreatedAtDesc(taskId);
        return ResponseEntity.ok(comments.stream()
                .map(CommentMapper::toDTO)
                .collect(Collectors.toList()));
    }

    @PostMapping
    public ResponseEntity<CommentDTO> createComment(
            @RequestBody CommentDTO commentDTO,
            @AuthenticationPrincipal UserDetails userDetails
    ) {
        Task task = taskRepository.findById(commentDTO.getTaskId())
                .orElseThrow(() -> new ResourceNotFoundException("Task not found"));

        User author = userRepository.findByUsername(userDetails.getUsername())
                .orElseThrow(() -> new ResourceNotFoundException("User not found"));

        Comment comment = new Comment();
        comment.setContent(commentDTO.getContent());
        comment.setTask(task);
        comment.setUser(author);

        Comment savedComment = commentRepository.save(comment);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(CommentMapper.toDTO(savedComment));
    }

    @DeleteMapping
    public void deleteComment(@RequestParam Long id) {
        commentRepository.deleteById(id);
    }
}


===== File: ./Board/controller/TaskController.java =====
package Backend.Board.controller;

import java.util.List;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

import Backend.Board.dto.BoardDTO;
import Backend.Board.dto.CommentDTO;
import Backend.Board.dto.TaskDTO;
import Backend.Board.exception.ResourceNotFoundException;
import Backend.Board.mappers.BoardMapper;
import Backend.Board.mappers.UserMapper;
import Backend.Board.model.Board;
import Backend.Board.model.Column;
import Backend.Board.model.Task;
import Backend.Board.model.User;
import Backend.Board.repository.BoardRepository;
import Backend.Board.repository.ColumnRepository;
import Backend.Board.repository.TaskRepository;
import Backend.Board.repository.UserRepository;

@RestController
@RequestMapping("/tasks")
public class TaskController {

    @Autowired
    private TaskRepository taskRepository;

    @Autowired
    private BoardRepository boardRepository;

    @Autowired
    private SimpMessagingTemplate messagingTemplate;

    @Autowired
    private UserRepository userRepository;

    @Autowired ColumnRepository columnRepository;

    @GetMapping("/{id}")
    public ResponseEntity<TaskDTO> getTaskById(@PathVariable Long id) {
        return taskRepository.findById(id)
                .map(task -> {
                    List<CommentDTO> commentDTOs = task.getComments().stream()
                            .map(comment -> new CommentDTO(
                                    comment.getId(),
                                    comment.getContent(),
                                    comment.getCreatedAt(),
                                    UserMapper.toDTO(comment.getUser()),
                                    comment.getTask().getId()))
                            .collect(Collectors.toList());

                    return ResponseEntity.ok(new TaskDTO(
                            task.getId(),
                            task.getTitle(),
                            task.getDescription(),
                            commentDTOs,
                            UserMapper.toDTO(task.getCreatedBy()),
                            UserMapper.toDTO(task.getAssignee()))
                            );
                })
                .orElse(ResponseEntity.notFound().build());
    }

     @PostMapping
    public ResponseEntity<Task> createTask(
            @RequestParam Long boardId,
            @RequestParam Long columnId,
            @RequestBody Task task,
            @AuthenticationPrincipal UserDetails userDetails) {
        
        // Fetch the board and column
        Board board = boardRepository.findById(boardId)
                .orElseThrow(() -> new ResourceNotFoundException("Board not found"));
        Column column = columnRepository.findById(columnId)
                .orElseThrow(() -> new ResourceNotFoundException("Column not found"));

        // Fetch the user who created the task
        User creator = userRepository.findByUsername(userDetails.getUsername())
                .orElseThrow(() -> new ResourceNotFoundException("User not found"));

        // Set the task's column and createdBy user
        task.setColumn(column);
        task.setCreatedBy(creator);

        // Validate the task title
        if (task.getTitle() == null || task.getTitle().trim().isEmpty()) {
            return ResponseEntity.badRequest().build();
        }

        // Save the task
        Task savedTask = taskRepository.save(task);

        // Send the updated board state via WebSocket
        sendBoardUpdate(boardId);

        return ResponseEntity.status(HttpStatus.CREATED).body(savedTask);
    }

    @PutMapping("/{id}")
    public ResponseEntity<Task> updateTask(@PathVariable Long id, @RequestBody Task updatedTask) {
        if (updatedTask.getTitle() == null || updatedTask.getTitle().trim().isEmpty()) {
            return ResponseEntity.badRequest().build();
        }

        return taskRepository.findById(id)
                .map(task -> {
                    task.setTitle(updatedTask.getTitle());
                    task.setDescription(updatedTask.getDescription());
                    Task savedTask = taskRepository.save(task);
                    sendBoardUpdate(savedTask.getId());
                    return ResponseEntity.ok(savedTask);
                })
                .orElseGet(() -> ResponseEntity.notFound().build());
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Object> deleteTask(@PathVariable Long id) {
        return taskRepository.findByIdWithColumnAndBoard(id)
                .map(task -> {
                    Long boardId = task.getColumn().getBoard().getId();
                    taskRepository.delete(task);
                    taskRepository.flush(); // Critical for immediate sync

                    sendBoardUpdateDirect(boardId);
                    return ResponseEntity.noContent().build();
                })
                .orElseGet(() -> ResponseEntity.notFound().build());
    }

    private void sendBoardUpdateDirect(Long boardId) {
        boardRepository.findById(boardId)
                .ifPresent(board -> {
                    BoardDTO dto = BoardMapper.toDTO(board);
                    messagingTemplate.convertAndSend(
                            "/topic/board/" + boardId,
                            dto);
                });
    }

    private void sendBoardUpdate(Long taskId) {
        taskRepository.findByIdWithColumnAndBoard(taskId)
                .ifPresent(task -> {
                    Long boardId = task.getColumn().getBoard().getId();
                    boardRepository.findById(boardId)
                            .ifPresent(board -> {
                                BoardDTO dto = BoardMapper.toDTO(board);
                                messagingTemplate.convertAndSend(
                                        "/topic/board/" + boardId,
                                        dto);
                            });
                });
    }
}


===== File: ./Board/controller/ColumnController.java =====
package Backend.Board.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import Backend.Board.model.Column;
import Backend.Board.repository.ColumnRepository;

@RestController
@RequestMapping("/columns")
public class ColumnController {

    @Autowired
    private ColumnRepository columnRepository;

    @GetMapping
    public List<Column> getAllColumns(@RequestParam(required = false) Long id) {
        if (id != null) {
            return columnRepository.findById(id).map(List::of)
                    .orElseThrow(() -> new RuntimeException("Column not found"));
        }
        return columnRepository.findAll();
    }

    @PostMapping
    public Column createColumn(@RequestBody Column column) {
        return columnRepository.save(column);
    }

    @DeleteMapping
    public void deleteColumn(@RequestParam Long id) {
        columnRepository.deleteById(id);
    }
}


===== File: ./Board/controller/BoardController.java =====
package Backend.Board.controller;

import Backend.Board.dto.BoardDTO;
import Backend.Board.exception.ResourceNotFoundException;
import Backend.Board.mappers.BoardMapper;
import Backend.Board.model.Board;
import Backend.Board.model.BoardRoleType;
import Backend.Board.model.Column;
import Backend.Board.model.Task;
import Backend.Board.model.User;
import Backend.Board.repository.BoardRepository;
import Backend.Board.repository.UserRepository;
import Backend.Board.service.BoardRoleService;
import Backend.Board.service.BoardWebSocketService;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.messaging.Message;
import org.springframework.messaging.handler.annotation.DestinationVariable;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.SendTo;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import java.util.UUID;
import java.util.stream.Collectors;

@RestController
@Controller
@RequestMapping("/boards")
@SecurityRequirement(name = "bearerAuth")
public class BoardController {

    @Autowired
    private BoardRepository boardRepository;

    @Autowired
    private BoardWebSocketService boardWebSocketService;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private BoardRoleService boardRoleService;

    private static final List<String> COLUMN_NAMES = Arrays.asList("Backlog", "To Do", "In Progress", "Review", "Done");

    @GetMapping
    public List<BoardDTO> getAllBoards(@RequestParam(required = false) Long id) {
        List<Board> boards = id != null ? boardRepository.findById(id).map(List::of)
                .orElseThrow(() -> new RuntimeException("Board not found")) : boardRepository.findAll();

        return boards.stream()
                .map(BoardMapper::toDTO)
                .collect(Collectors.toList());
    }

    @MessageMapping("/board/{boardId}/update")
    @SendTo("/topic/board/{boardId}")
    public BoardDTO updateBoard(
            @DestinationVariable Long boardId,
            Message<BoardDTO> message) {
        return boardWebSocketService.handleBoardUpdate(boardId, message.getPayload());
    }

    @PostMapping
    public BoardDTO createBoard(@RequestBody BoardDTO board) {
        return BoardMapper.toDTO(boardRepository.save(BoardMapper.toEntity(board)));
    }

    @DeleteMapping
    public void deleteBoard(@RequestParam Long id) {
        boardRepository.deleteById(id);
    }

    @PostMapping("/{boardId}/users/{userId}/role")
    @PreAuthorize("@boardSecurityService.hasBoardAccess(authentication, #boardId)")
    public ResponseEntity<?> assignUserRoleToBoard(
            @PathVariable Long boardId,
            @PathVariable Long userId,
            @RequestParam BoardRoleType role) {
        Board board = boardRepository.findById(boardId)
                .orElseThrow(() -> new ResourceNotFoundException("Board not found"));
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User not found"));

        boardRoleService.assignRoleToUser(user, board, role);
        return ResponseEntity.ok("Role assigned");
    }

    @GetMapping("/{boardId}/users/{userId}/role")
    public ResponseEntity<BoardRoleType> getUserBoardRole(
            @PathVariable Long boardId,
            @PathVariable Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User not found"));
        return ResponseEntity.ok(boardRoleService.getUserRoleForBoard(user, boardId));
    }

    @PostMapping("/random")
    public ResponseEntity<BoardDTO> createRandomBoard() {
        try {
            Random random = new Random();
            Board board = new Board();
            board.setName("Board-" + UUID.randomUUID().toString().substring(0, 8));

            List<Column> columns = new ArrayList<>();
            int columnCount = 2 + random.nextInt(4);

            List<String> shuffledColumnNames = new ArrayList<>(COLUMN_NAMES);
            Collections.shuffle(shuffledColumnNames);

            for (int i = 0; i < columnCount; i++) {
                Column column = new Column();
                String columnName = i < shuffledColumnNames.size()
                        ? shuffledColumnNames.get(i)
                        : "Column " + (i + 1);
                column.setName(columnName);
                column.setBoard(board);

                List<Task> tasks = new ArrayList<>();
                int taskCount = 1 + random.nextInt(6);

                for (int j = 0; j < taskCount; j++) {
                    Task task = new Task();
                    task.setTitle("Task " + (j + 1));
                    task.setDescription("Sample description for " + columnName);
                    task.setColumn(column);
                    tasks.add(task);
                }
                column.setTasks(tasks);
                columns.add(column);
            }

            board.setColumns(columns);
            Board savedBoard = boardRepository.save(board);
            return ResponseEntity.ok(BoardMapper.toDTO(savedBoard));
        } catch (Exception e) {
            return ResponseEntity.internalServerError().build();
        }
    }
}


===== File: ./Board/controller/AuthController.java =====
package Backend.Board.controller;

import Backend.Board.config.JwtUtil;
import Backend.Board.dto.UserRegisterDTO;
import Backend.Board.model.Role;
import Backend.Board.model.User;
import Backend.Board.repository.RoleRepository;
import Backend.Board.repository.UserRepository;
import Backend.Board.service.CustomUserDetailsService;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.*;

import lombok.AllArgsConstructor;
import lombok.Data;

@RestController
@RequestMapping("/api/auth")
public class AuthController {

    @Autowired
    private AuthenticationManager authenticationManager;

    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    private RoleRepository roleRepository;

    @Autowired
    private CustomUserDetailsService userDetailsService;

    @Autowired
    private UserRepository userRepository;

    @PostMapping("/login")
    public ResponseEntity<?> createAuthenticationToken(@RequestBody AuthenticationRequest authenticationRequest) {
        authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(authenticationRequest.getUsername(),
                        authenticationRequest.getPassword()));
        final UserDetails userDetails = userDetailsService.loadUserByUsername(authenticationRequest.getUsername());
        final String jwt = jwtUtil.generateToken(userDetails);
        return ResponseEntity.ok(new AuthenticationResponse(jwt));
    }

    @PostMapping("/register")
    public ResponseEntity<?> registerUser(@RequestBody UserRegisterDTO userDTO) {
        if (userRepository.existsByUsername(userDTO.getUsername())) {
            return ResponseEntity.badRequest().body("Username is already taken");
        }

        User user = new User();
        user.setUsername(userDTO.getUsername());
        user.setPassword(passwordEncoder().encode(userDTO.getPassword()));
        user.setName(userDTO.getName());

        // Assign default role if needed
        Role userRole = roleRepository.findByName("USER")
                .orElseThrow(() -> new RuntimeException("Default role not found"));
        user.setRoles(List.of(userRole));

        userRepository.save(user);
        return ResponseEntity.ok("User registered successfully");
    }

    private PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Data
    static class AuthenticationRequest {
        private String username;
        private String password;
    }

    @Data
    @AllArgsConstructor
    static class AuthenticationResponse {
        private String token;
    }
}

class AuthenticationRequest {
    private String username;
    private String password;
    // getters and setters
}

class AuthenticationResponse {
    private String token;
    // constructor and getter
}


===== File: ./Board/controller/UserController.java =====
package Backend.Board.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import Backend.Board.exception.ResourceNotFoundException;
import Backend.Board.model.Role;
import Backend.Board.model.User;
import Backend.Board.repository.RoleRepository;
import Backend.Board.repository.UserRepository;

import org.springframework.http.HttpStatus;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;

@RestController
@RequestMapping("/users")
public class UserController {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private RoleRepository roleRepository;

    @GetMapping
    public List<User> getAllUsers(@RequestParam(required = false) Long id) {
        if (id != null) {
            return userRepository.findById(id).map(List::of).orElseThrow(() -> new RuntimeException("User not found"));
        }
        return userRepository.findAll();
    }

    @GetMapping("/current")
    public ResponseEntity<User> getCurrentUser(@AuthenticationPrincipal UserDetails userDetails) {
        if (userDetails == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
        }

        User user = userRepository.findByUsername(userDetails.getUsername())
                .orElseThrow(() -> new ResourceNotFoundException("User not found"));

        return ResponseEntity.ok(user);
    }

    @PostMapping("/{userId}/promote-to-admin")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<?> promoteToAdmin(@PathVariable Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User not found"));

        Role adminRole = roleRepository.findByName("ADMIN")
                .orElseThrow(() -> new RuntimeException("Admin role not found"));

        user.getRoles().add(adminRole);
        userRepository.save(user);
        return ResponseEntity.ok("User promoted to admin");
    }

    @PostMapping
    public User createUser(@RequestBody User user) {
        return userRepository.save(user);
    }

    @DeleteMapping
    public void deleteUser(@RequestParam Long id) {
        userRepository.deleteById(id);
    }
}

===== File: ./Board/model/User.java =====
package Backend.Board.model;

import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "users")
public class User implements UserDetails {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String password;
    private String username;
    private boolean enabled = true;

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(name = "user_roles", joinColumns = @JoinColumn(name = "user_id"), inverseJoinColumns = @JoinColumn(name = "role_id"))
    @JsonIgnoreProperties({"users"}) // Add this
    private List<Role> roles;

    @JsonIgnore
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return roles.stream()
                .map(role -> new SimpleGrantedAuthority(role.getName()))
                .collect(Collectors.toList());
    }

    @JsonIgnore
    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @JsonIgnore
    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @JsonIgnore
    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @JsonIgnore
    @Override
    public boolean isEnabled() {
        return true;
    }
}


===== File: ./Board/model/Column.java =====
package Backend.Board.model;

import java.util.ArrayList;
import java.util.List;

import org.hibernate.annotations.BatchSize;

import com.fasterxml.jackson.annotation.JsonIgnore;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Column {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @ManyToOne
    @JoinColumn(name = "board_id")
    @JsonIgnore
    private Board board;

    @OneToMany(mappedBy = "column", cascade = CascadeType.ALL, orphanRemoval = true)
    @JsonIgnore
    @BatchSize(size = 100) // Fetch tasks in batches of 100
    private List<Task> tasks = new ArrayList<>();
}


===== File: ./Board/model/Comment.java =====
package Backend.Board.model;

import java.time.LocalDateTime;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import jakarta.persistence.Column;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Comment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String content;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;

    @ManyToOne
    @JoinColumn(name = "task_id")
    private Task task;

    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }
}


===== File: ./Board/model/Task.java =====
package Backend.Board.model;

import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

import com.fasterxml.jackson.annotation.JsonIgnore;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Task {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String title;

    @Lob
    private String description;

    @ManyToOne
    @JoinColumn(name = "column_id")
    @JsonIgnore
    private Column column;

    @OneToMany(mappedBy = "task", cascade = CascadeType.ALL, orphanRemoval = true)
    @JsonIgnore
    private List<Comment> comments;

    @ManyToOne
    @JoinColumn(name = "created_by")
    private User createdBy;

    @ManyToOne
    @JoinColumn(name = "assignee_id")
    private User assignee;
}


===== File: ./Board/model/Board.java =====
package Backend.Board.model;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.List;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Board {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @OneToMany(mappedBy = "board", cascade = CascadeType.ALL, orphanRemoval = true)
    @JsonIgnore
    private List<Column> columns = new ArrayList<>();

    @ManyToMany
    @JoinTable(name = "board_users", joinColumns = @JoinColumn(name = "board_id"), inverseJoinColumns = @JoinColumn(name = "user_id"))
    @JsonIgnore
    private List<User> users;
}


===== File: ./Board/model/UserBoardRole.java =====
package Backend.Board.model;

import jakarta.persistence.*;
import lombok.Data;

@Entity
@Data
public class UserBoardRole {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    private User user;

    @ManyToOne
    private Board board;

    @Enumerated(EnumType.STRING)
    private BoardRoleType role;
}


===== File: ./Board/model/BoardRoleType.java =====
package Backend.Board.model;

public enum BoardRoleType {
    ADMIN, WRITER, READER
}


===== File: ./Board/model/Role.java =====
package Backend.Board.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.security.core.GrantedAuthority;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@JsonIgnoreProperties({ "users" })
public class Role implements GrantedAuthority {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @JsonIgnore
    @Override
    public String getAuthority() {
        return name;
    }
}


===== File: ./Board/BoardApplication.java =====
package Backend.Board;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.transaction.annotation.EnableTransactionManagement;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@SpringBootApplication(exclude = { SecurityAutoConfiguration.class })
@EnableTransactionManagement
public class BoardApplication {

	public static void main(String[] args) {
		SpringApplication.run(BoardApplication.class, args);
	}

	@Bean
	public WebMvcConfigurer corsConfigurer() {
		return new WebMvcConfigurer() {
			@Override
			public void addCorsMappings(CorsRegistry registry) {
				registry.addMapping("/**")
	.allowedOrigins("http://localhost:4200")
						.allowedMethods("GET", "POST", "PUT", "DELETE");
			}
		};
	}
}


===== File: ./Board/mappers/CommentMapper.java =====
package Backend.Board.mappers;

import Backend.Board.dto.CommentDTO;
import Backend.Board.model.Comment;

public class CommentMapper {
    public static CommentDTO toDTO(Comment comment) {
        if (comment == null) return null;

        return new CommentDTO(
                comment.getId(),
                comment.getContent(),
                comment.getCreatedAt(),
                UserMapper.toDTO(comment.getUser()),
                comment.getTask().getId() // Add task ID
        );
    }

    public static Comment toEntity(CommentDTO commentDTO) {
        if (commentDTO == null)
            return null;

        Comment comment = new Comment();
        comment.setId(commentDTO.getId());
        comment.setContent(commentDTO.getContent());
        // User and task should be set in service layer
        return comment;
    }
}


===== File: ./Board/mappers/TaskMapper.java =====
package Backend.Board.mappers;

import java.util.List;
import java.util.stream.Collectors;

import Backend.Board.dto.CommentDTO;
import Backend.Board.dto.TaskDTO;
import Backend.Board.dto.TaskPreviewDTO;
import Backend.Board.model.Comment;
import Backend.Board.model.Task;

public class TaskMapper {
    public static TaskDTO toDTO(Task task) {
        if (task == null) {
            return null;
        }
        TaskDTO taskDTO = new TaskDTO();
        taskDTO.setId(task.getId());
        taskDTO.setTitle(task.getTitle());
        taskDTO.setCreatedBy(UserMapper.toDTO(task.getCreatedBy()));
        taskDTO.setAssignee(UserMapper.toDTO(task.getAssignee()));
        taskDTO.setDescription(task.getDescription());
        if (task.getComments() != null) {
            List<CommentDTO> commentDTOs = task.getComments().stream()
                    .map(CommentMapper::toDTO)
                    .collect(Collectors.toList());
            taskDTO.setComments(commentDTOs);
        }
        return taskDTO;
    }

    public static TaskPreviewDTO toPreviewDTO(Task task) {
        if (task == null) {
            return null;
        }
        TaskPreviewDTO taskPreviewDTO = new TaskPreviewDTO();
        taskPreviewDTO.setId(task.getId());
        taskPreviewDTO.setTitle(task.getTitle());
        return taskPreviewDTO;
    }

    public static Task toEntity(TaskDTO taskDTO) {
        if (taskDTO == null) {
            return null;
        }
        Task task = new Task();
        task.setId(taskDTO.getId());
        task.setTitle(taskDTO.getTitle());
        task.setCreatedBy(UserMapper.toEntity(taskDTO.getCreatedBy()));
        task.setAssignee(UserMapper.toEntity(taskDTO.getAssignee()));
        task.setDescription(taskDTO.getDescription());
        if (taskDTO.getComments() != null) {
            List<Comment> comments = taskDTO.getComments().stream()
                    .map(CommentMapper::toEntity)
                    .collect(Collectors.toList());
            task.setComments(comments);
        }
        return task;
    }

    public static Task toEntityFromPreview(TaskPreviewDTO taskPreviewDTO) {
        if (taskPreviewDTO == null) {
            return null;
        }
        Task task = new Task();
        task.setId(taskPreviewDTO.getId());
        task.setTitle(taskPreviewDTO.getTitle());
        return task;
    }
}


===== File: ./Board/mappers/ColumnMapper.java =====
package Backend.Board.mappers;

import java.util.List;
import java.util.stream.Collectors;

import Backend.Board.dto.ColumnDTO;
import Backend.Board.dto.TaskPreviewDTO;
import Backend.Board.model.Column;
import Backend.Board.model.Task;

public class ColumnMapper {
    public static ColumnDTO toDTO(Column column) {
        if (column == null) {
            return null;
        }
        ColumnDTO columnDTO = new ColumnDTO();
        columnDTO.setId(column.getId());
        columnDTO.setName(column.getName());
        if (column.getTasks() != null) {
            List<TaskPreviewDTO> taskPreviewDTOs = column.getTasks().stream()
                    .map(TaskMapper::toPreviewDTO)
                    .collect(Collectors.toList());
            columnDTO.setTasks(taskPreviewDTOs);
        }
        return columnDTO;
    }

    public static Column toEntity(ColumnDTO columnDTO) {
        if (columnDTO == null) {
            return null;
        }
        Column column = new Column();
        column.setId(columnDTO.getId());
        column.setName(columnDTO.getName());
        if (columnDTO.getTasks() != null) {
            List<Task> tasks = columnDTO.getTasks().stream()
                    .map(TaskMapper::toEntityFromPreview)
                    .collect(Collectors.toList());
            column.setTasks(tasks);
        }
        return column;
    }

}


===== File: ./Board/mappers/UserMapper.java =====
package Backend.Board.mappers;

import Backend.Board.dto.UserDTO;
import Backend.Board.model.User;

public class UserMapper {
    public static UserDTO toDTO(User user) {
        if (user == null)
            return null;
        return new UserDTO(user.getId(), user.getUsername(), user.getName());
    }

    public static User toEntity(UserDTO userDTO) {
        if (userDTO == null)
            return null;
        User user = new User();
        user.setId(userDTO.getId());
        user.setUsername(userDTO.getUsername());
        user.setName(userDTO.getName());
        return user;
    }
}


===== File: ./Board/mappers/BoardMapper.java =====
package Backend.Board.mappers;

import Backend.Board.dto.BoardDTO;
import Backend.Board.dto.ColumnDTO;
import Backend.Board.model.Board;
import Backend.Board.model.Column;
import java.util.List;
import java.util.stream.Collectors;

public class BoardMapper {

    public static BoardDTO toDTO(Board board) {
        if (board == null) {
            return null;
        }
        BoardDTO boardDTO = new BoardDTO();
        boardDTO.setId(board.getId());
        boardDTO.setName(board.getName());
        if (board.getColumns() != null) {
            List<ColumnDTO> columnDTOs = board.getColumns().stream()
                    .map(ColumnMapper::toDTO)
                    .collect(Collectors.toList());
            boardDTO.setColumns(columnDTOs);
        }
        return boardDTO;
    }

    public static Board toEntity(BoardDTO boardDTO) {
        if (boardDTO == null) {
            return null;
        }
        Board board = new Board();
        board.setId(boardDTO.getId());
        board.setName(boardDTO.getName());
        if (boardDTO.getColumns() != null) {
            List<Column> columns = boardDTO.getColumns().stream()
                    .map(ColumnMapper::toEntity)
                    .collect(Collectors.toList());
            board.setColumns(columns);
        }
        return board;
    }
}


===== File: ./Board/service/BoardSecurityService.java =====
package Backend.Board.service;

import Backend.Board.model.BoardRoleType;
import Backend.Board.model.User;
import Backend.Board.repository.UserBoardRoleRepository;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;

@Service
public class BoardSecurityService {
    @Autowired
    private UserBoardRoleRepository userBoardRoleRepository;

    @Autowired
    private BoardRoleService boardRoleService;

    public boolean hasBoardPermission(Authentication authentication, Long boardId, BoardRoleType requiredRole) {
        User user = (User) authentication.getPrincipal();
        BoardRoleType userRole = boardRoleService.getUserRoleForBoard(user, boardId);
        
        return switch (requiredRole) {
            case ADMIN -> userRole == BoardRoleType.ADMIN;
            case WRITER -> userRole == BoardRoleType.ADMIN || userRole == BoardRoleType.WRITER;
            case READER -> userRole != null;
        };
    }

    public boolean hasBoardAccess(Authentication authentication, Long boardId) {
        User user = (User) authentication.getPrincipal();
        return userBoardRoleRepository.existsByUserAndBoardIdAndRoleIn(
                user,
                boardId,
                List.of(BoardRoleType.ADMIN, BoardRoleType.WRITER, BoardRoleType.READER)
        );
    }
}


===== File: ./Board/service/BoardWebSocketService.java =====
package Backend.Board.service;

import Backend.Board.dto.BoardDTO;
import Backend.Board.dto.ColumnDTO;
import Backend.Board.dto.TaskPreviewDTO;
import Backend.Board.mappers.BoardMapper;
import Backend.Board.model.Board;
import Backend.Board.model.Column;
import Backend.Board.model.Task;
import Backend.Board.repository.BoardRepository;
import Backend.Board.repository.TaskRepository;
import jakarta.transaction.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class BoardWebSocketService {

    @Autowired
    private BoardRepository boardRepository;

    @Autowired
    private TaskRepository taskRepository;

    @Transactional
    public BoardDTO handleBoardUpdate(Long boardId, BoardDTO updatedBoardDTO) {
        System.out.println("Handling board update for board: " + boardId);
        Board existingBoard = boardRepository.findById(boardId)
                .orElseThrow(() -> new RuntimeException("Board not found with id: " + boardId));

        existingBoard.setName(updatedBoardDTO.getName());
        updateColumns(existingBoard, updatedBoardDTO.getColumns());
        Board savedBoard = boardRepository.save(existingBoard);
        return BoardMapper.toDTO(savedBoard);
    }

    private void updateColumns(Board existingBoard, List<ColumnDTO> updatedColumns) {
        Map<Long, Column> existingColumnsMap = existingBoard.getColumns().stream()
                .collect(Collectors.toMap(Column::getId, c -> c));

        List<Column> newColumns = new ArrayList<>();

        for (ColumnDTO columnDTO : updatedColumns) {
            Column column = existingColumnsMap.getOrDefault(columnDTO.getId(), new Column());
            column.setName(columnDTO.getName());
            column.setBoard(existingBoard);
            updateTasks(column, columnDTO.getTasks());
            newColumns.add(column);
            existingColumnsMap.remove(column.getId());
        }

        existingBoard.getColumns().removeAll(existingColumnsMap.values());
        existingBoard.getColumns().clear();
        existingBoard.getColumns().addAll(newColumns);
    }

    private void updateTasks(Column column, List<TaskPreviewDTO> updatedTasks) {
        Map<Long, Task> existingTasksMap = column.getTasks().stream()
                .collect(Collectors.toMap(Task::getId, t -> t));

        List<Task> newTasks = new ArrayList<>();

        for (TaskPreviewDTO taskDTO : updatedTasks) {
            Task task = existingTasksMap.getOrDefault(taskDTO.getId(), new Task());
            Optional<Task> taskInRepo = taskRepository.findById(taskDTO.getId());

            task.setColumn(column);
            task.setTitle(taskInRepo.get().getTitle());
            task.setDescription(taskInRepo.get().getDescription());
            task.setComments(taskInRepo.get().getComments());

            newTasks.add(task);
            existingTasksMap.remove(task.getId());
        }

        column.getTasks().removeAll(existingTasksMap.values());
        column.getTasks().clear();
        column.getTasks().addAll(newTasks);
    }
}


===== File: ./Board/service/BoardRoleService.java =====
package Backend.Board.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import Backend.Board.model.Board;
import Backend.Board.model.BoardRoleType;
import Backend.Board.model.User;
import Backend.Board.model.UserBoardRole;
import Backend.Board.repository.UserBoardRoleRepository;

@Service
public class BoardRoleService {
    @Autowired
    private UserBoardRoleRepository userBoardRoleRepository;
    
    public void assignRoleToUser(User user, Board board, BoardRoleType role) {
        UserBoardRole userBoardRole = new UserBoardRole();
        userBoardRole.setUser(user);
        userBoardRole.setBoard(board);
        userBoardRole.setRole(role);
        userBoardRoleRepository.save(userBoardRole);
    }

    public BoardRoleType getUserRoleForBoard(User user, Long boardId) {
        return userBoardRoleRepository.findByUserAndBoardId(user, boardId)
                .map(UserBoardRole::getRole)
                .orElse(null);
    }
}

===== File: ./Board/service/CustomUserDetailsService.java =====
package Backend.Board.service;

import Backend.Board.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
public class CustomUserDetailsService implements UserDetailsService {
    @Autowired
    private UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        return userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));
    }
}


===== File: ./Board/exception/ResourceNotFoundException.java =====
package Backend.Board.exception;

public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}

